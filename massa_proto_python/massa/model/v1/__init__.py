# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: massa/model/v1/address.proto, massa/model/v1/amount.proto, massa/model/v1/block.proto, massa/model/v1/commons.proto, massa/model/v1/datastore.proto, massa/model/v1/denunciation.proto, massa/model/v1/draw.proto, massa/model/v1/endorsement.proto, massa/model/v1/execution.proto, massa/model/v1/node.proto, massa/model/v1/operation.proto, massa/model/v1/slot.proto, massa/model/v1/staker.proto, massa/model/v1/stats.proto, massa/model/v1/time.proto, massa/model/v1/versioning.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    List,
    Optional,
)

import betterproto


class AddressCategory(betterproto.Enum):
    """Address category discriminant"""

    ADDRESS_CATEGORY_UNSPECIFIED = 0
    """Unspecified address category"""

    ADDRESS_CATEGORY_USER_ADDRESS = 1
    """User address"""

    ADDRESS_CATEGORY_SC_ADDRESS = 2
    """Smart contract address"""


class ComparisonResult(betterproto.Enum):
    """Comparison result"""

    COMPARISON_RESULT_UNSPECIFIED = 0
    COMPARISON_RESULT_LOWER = 1
    """left is lower"""

    COMPARISON_RESULT_EQUAL = 2
    """left and right are equal"""

    COMPARISON_RESULT_GREATER = 3
    """left is greater"""


class OpType(betterproto.Enum):
    """Operation type enum"""

    OP_TYPE_UNSPECIFIED = 0
    OP_TYPE_TRANSACTION = 1
    OP_TYPE_ROLL_BUY = 2
    OP_TYPE_ROLL_SELL = 3
    OP_TYPE_EXECUTE_SC = 4
    OP_TYPE_CALL_SC = 5


class BlockStatus(betterproto.Enum):
    """Possible statuses for a block"""

    BLOCK_STATUS_UNSPECIFIED = 0
    BLOCK_STATUS_NON_FINAL_BLOCKCLIQUE = 1
    BLOCK_STATUS_FINAL = 2
    BLOCK_STATUS_NON_FINAL_ALTERNATE_CLIQUE = 3
    BLOCK_STATUS_DISCARDED = 4


class ScExecutionEventStatus(betterproto.Enum):
    """ScExecutionEventStatus type enum"""

    SC_EXECUTION_EVENT_STATUS_UNSPECIFIED = 0
    SC_EXECUTION_EVENT_STATUS_FINAL = 1
    SC_EXECUTION_EVENT_STATUS_READ_ONLY = 2
    SC_EXECUTION_EVENT_STATUS_CANDIDATE = 3


class ExecutionOutputStatus(betterproto.Enum):
    """ExecutionOutputStatus type enum"""

    EXECUTION_OUTPUT_STATUS_UNSPECIFIED = 0
    EXECUTION_OUTPUT_STATUS_CANDIDATE = 1
    EXECUTION_OUTPUT_STATUS_FINAL = 2
    EXECUTION_OUTPUT_STATUS_UNKNOWN = 3


class OperationExecutionStatus(betterproto.Enum):
    """OperationExecutionStatus type enum"""

    OPERATION_EXECUTION_STATUS_UNSPECIFIED = 0
    OPERATION_EXECUTION_STATUS_SUCCESS = 1
    OPERATION_EXECUTION_STATUS_FAILED = 2


class AsyncPoolChangeType(betterproto.Enum):
    """AsyncPoolChangeType type enum"""

    ASYNC_POOL_CHANGE_TYPE_UNSPECIFIED = 0
    ASYNC_POOL_CHANGE_TYPE_SET = 1
    ASYNC_POOL_CHANGE_TYPE_UPDATE = 2
    ASYNC_POOL_CHANGE_TYPE_DELETE = 3


class LedgerChangeType(betterproto.Enum):
    """LedgerChangeType type enum"""

    LEDGER_CHANGE_TYPE_UNSPECIFIED = 0
    LEDGER_CHANGE_TYPE_SET = 1
    LEDGER_CHANGE_TYPE_UPDATE = 2
    LEDGER_CHANGE_TYPE_DELETE = 3


class ConnectionType(betterproto.Enum):
    """ConnectionType enum"""

    CONNECTION_TYPE_UNSPECIFIED = 0
    CONNECTION_TYPE_INCOMING = 1
    CONNECTION_TYPE_OUTGOING = 2


class ComponentStateId(betterproto.Enum):
    """
    State machine for a Versioning component that tracks the deployment state
    """

    COMPONENT_STATE_ID_UNSPECIFIED = 0
    COMPONENT_STATE_ID_ERROR = 1
    COMPONENT_STATE_ID_DEFINED = 2
    COMPONENT_STATE_ID_STARTED = 3
    COMPONENT_STATE_ID_LOCKEDIN = 4
    COMPONENT_STATE_ID_ACTIVE = 5
    COMPONENT_STATE_ID_FAILED = 6


class MipComponent(betterproto.Enum):
    """Versioning component enum"""

    MIP_COMPONENT_UNSPECIFIED = 0
    MIP_COMPONENT_ADDRESS = 1
    MIP_COMPONENT_KEYPAIR = 2


@dataclass(eq=False, repr=False)
class NativeAddress(betterproto.Message):
    """Massa NativeAddress"""

    category: "AddressCategory" = betterproto.enum_field(1)
    """Address category"""

    version: int = betterproto.uint64_field(2)
    """Address version"""

    content: bytes = betterproto.bytes_field(3)
    """Address content"""


@dataclass(eq=False, repr=False)
class Addresses(betterproto.Message):
    """Addresses holds addresses"""

    addresses: List[str] = betterproto.string_field(1)
    """Addresses"""


@dataclass(eq=False, repr=False)
class NativeAmount(betterproto.Message):
    """
    NativeAmount is represented as a fraction so precision can be adjusted in
    the future. value = mantissa / (10^scale)
    """

    mantissa: int = betterproto.uint64_field(1)
    """Mantissa"""

    scale: int = betterproto.uint32_field(2)
    """Scale"""


@dataclass(eq=False, repr=False)
class IndexedSlot(betterproto.Message):
    """
    When an address is drawn to create an endorsement it is selected for a
    specific index
    """

    slot: "Slot" = betterproto.message_field(1)
    """Slot"""

    index: int = betterproto.uint64_field(2)
    """Endorsement index in the slot"""


@dataclass(eq=False, repr=False)
class Slot(betterproto.Message):
    """A point in time where a block is expected"""

    period: int = betterproto.uint64_field(1)
    """Period"""

    thread: int = betterproto.uint32_field(2)
    """Thread"""


@dataclass(eq=False, repr=False)
class Slots(betterproto.Message):
    """Slots"""

    slots: List["Slot"] = betterproto.message_field(1)
    """Slots"""


@dataclass(eq=False, repr=False)
class SlotRange(betterproto.Message):
    """SlotRange"""

    start_slot: "Slot" = betterproto.message_field(1)
    """Start lot (Optional)"""

    end_slot: "Slot" = betterproto.message_field(2)
    """End slot (Optional)"""


@dataclass(eq=False, repr=False)
class Denunciation(betterproto.Message):
    block_header: "BlockHeaderDenunciation" = betterproto.message_field(
        1, group="entry"
    )
    """Denunciation block header"""

    endorsement: "EndorsementDenunciation" = betterproto.message_field(2, group="entry")
    """Denunciation endorsement"""


@dataclass(eq=False, repr=False)
class BlockHeaderDenunciation(betterproto.Message):
    public_key: str = betterproto.string_field(1)
    """Denunciation public key"""

    slot: "Slot" = betterproto.message_field(2)
    """Denunciation slot"""

    hash_1: str = betterproto.string_field(3)
    """Denunciation hash 1"""

    hash_2: str = betterproto.string_field(4)
    """Denunciation hash 2"""

    signature_1: str = betterproto.string_field(5)
    """Denunciation sig 1"""

    signature_2: str = betterproto.string_field(6)
    """Denunciation sig 2"""


@dataclass(eq=False, repr=False)
class EndorsementDenunciation(betterproto.Message):
    public_key: str = betterproto.string_field(1)
    """Denunciation public key"""

    slot: "Slot" = betterproto.message_field(2)
    """Denunciation slot"""

    index: int = betterproto.uint32_field(3)
    """Denunciation index"""

    hash_1: str = betterproto.string_field(4)
    """Denunciation hash 1"""

    hash_2: str = betterproto.string_field(5)
    """Denunciation hash 2"""

    signature_1: str = betterproto.string_field(6)
    """Denunciation sig 1"""

    signature_2: str = betterproto.string_field(7)
    """Denunciation sig 2"""


@dataclass(eq=False, repr=False)
class DenunciationIndex(betterproto.Message):
    """Index for Denunciations in collections (e.g. like a HashMap...)"""

    block_header: "DenunciationBlockHeader" = betterproto.message_field(
        1, group="entry"
    )
    """Denunciation block header"""

    endorsement: "DenunciationEndorsement" = betterproto.message_field(2, group="entry")
    """Denunciation endorsement"""


@dataclass(eq=False, repr=False)
class DenunciationBlockHeader(betterproto.Message):
    """Variant for Block header denunciation index"""

    slot: "Slot" = betterproto.message_field(1)
    """Denunciation slot"""


@dataclass(eq=False, repr=False)
class DenunciationEndorsement(betterproto.Message):
    """Variant for Endorsement denunciation index"""

    slot: "Slot" = betterproto.message_field(1)
    """Denounciation slot"""

    index: int = betterproto.uint32_field(2)
    """Denounciation index"""


@dataclass(eq=False, repr=False)
class Endorsement(betterproto.Message):
    """An endorsement, as sent in the network"""

    slot: "Slot" = betterproto.message_field(1)
    """Slot in which the endorsement can be included"""

    index: int = betterproto.uint32_field(2)
    """Endorsement index inside the including block"""

    endorsed_block: str = betterproto.string_field(3)
    """
    Hash of endorsed block This is the parent in thread `self.slot.thread` of
    the block in which the endorsement is included
    """


@dataclass(eq=False, repr=False)
class SignedEndorsement(betterproto.Message):
    """Signed endorsement"""

    content: "Endorsement" = betterproto.message_field(1)
    """Endorsement"""

    signature: str = betterproto.string_field(2)
    """
    A cryptographically generated value using `serialized_data` and a public
    key.
    """

    content_creator_pub_key: str = betterproto.string_field(3)
    """The public-key component used in the generation of the signature"""

    content_creator_address: str = betterproto.string_field(4)
    """Derived from the same public key used to generate the signature"""

    secure_hash: str = betterproto.string_field(5)
    """
    A secure hash of the non-malleable contents of a deterministic binary
    representation of the block header
    """

    serialized_size: int = betterproto.uint64_field(6)
    """The size of the serialized endorsement in bytes"""


@dataclass(eq=False, repr=False)
class EndorsementIds(betterproto.Message):
    """EndorsementIds holds endorsements ids"""

    endorsement_ids: List[str] = betterproto.string_field(1)
    """Endorsements ids"""


@dataclass(eq=False, repr=False)
class EndorsementWrapper(betterproto.Message):
    """A wrapper around an endorsement with its metadata"""

    in_pool: bool = betterproto.bool_field(1)
    """Whether the endorsement is still in pool"""

    in_blocks: List[str] = betterproto.string_field(2)
    """
    The endorsement appears in `in_blocks` If it appears in multiple blocks,
    these blocks are in different cliques
    """

    is_final: bool = betterproto.bool_field(3)
    """Whether the the endorsement is final (for example in a final block)"""

    endorsement: "SignedEndorsement" = betterproto.message_field(4)
    """The endorsement itself"""


@dataclass(eq=False, repr=False)
class EndorsementInfo(betterproto.Message):
    """Informations about an endorsement with its metadata"""

    endorsement_id: str = betterproto.string_field(1)
    """The endorsement id"""

    in_pool: bool = betterproto.bool_field(2)
    """Whether the endorsement is still in pool"""

    in_blocks: List[str] = betterproto.string_field(3)
    """
    The endorsement appears in `in_blocks` If it appears in multiple blocks,
    these blocks are in different cliques
    """

    is_final: bool = betterproto.bool_field(4)
    """Whether the the endorsement is final (for example in a final block)"""


@dataclass(eq=False, repr=False)
class Error(betterproto.Message):
    """Massa error"""

    code: int = betterproto.int32_field(1)
    """The error code"""

    message: str = betterproto.string_field(2)
    """A developer-facing error message, which should be in English"""


@dataclass(eq=False, repr=False)
class Empty(betterproto.Message):
    """Empty"""

    pass


@dataclass(eq=False, repr=False)
class BytesMapFieldEntry(betterproto.Message):
    """BytesMapFieldEntry"""

    key: bytes = betterproto.bytes_field(1)
    """bytes key"""

    value: bytes = betterproto.bytes_field(2)
    """bytes key"""


@dataclass(eq=False, repr=False)
class ArrayOfBytesWrapper(betterproto.Message):
    """Array of bytes wrapper"""

    items: List[bytes] = betterproto.bytes_field(1)
    """Repeated bytes"""


@dataclass(eq=False, repr=False)
class KeyPair(betterproto.Message):
    """KeyPair"""

    public_key: str = betterproto.string_field(1)
    """Public key"""

    secret_key: str = betterproto.string_field(2)
    """Secret key"""


@dataclass(eq=False, repr=False)
class Operation(betterproto.Message):
    """The operation as sent in the network"""

    fee: "NativeAmount" = betterproto.message_field(1)
    """The fee they have decided for this operation"""

    expire_period: int = betterproto.uint64_field(2)
    """
    After `expire_period` slot the operation won't be included in a block
    """

    op: "OperationType" = betterproto.message_field(3)
    """The type specific operation part"""


@dataclass(eq=False, repr=False)
class OperationType(betterproto.Message):
    """Type specific operation content"""

    transaction: "Transaction" = betterproto.message_field(1, group="type")
    """Transfer coins from sender to recipient"""

    roll_buy: "RollBuy" = betterproto.message_field(2, group="type")
    """
    The sender buys `roll_count` rolls. Roll price is defined in configuration
    """

    roll_sell: "RollSell" = betterproto.message_field(3, group="type")
    """
    The sender sells `roll_count` rolls. Roll price is defined in configuration
    """

    execut_sc: "ExecuteSc" = betterproto.message_field(4, group="type")
    """Execute a smart contract"""

    call_sc: "CallSc" = betterproto.message_field(5, group="type")
    """Calls an exported function from a stored smart contract"""


@dataclass(eq=False, repr=False)
class Transaction(betterproto.Message):
    """Transfer coins from sender to recipient"""

    recipient_address: str = betterproto.string_field(1)
    """Recipient address"""

    amount: "NativeAmount" = betterproto.message_field(2)
    """Amount"""


@dataclass(eq=False, repr=False)
class RollBuy(betterproto.Message):
    """
    The sender buys `roll_count` rolls. Roll price is defined in configuration
    """

    roll_count: int = betterproto.uint64_field(1)
    """Roll count"""


@dataclass(eq=False, repr=False)
class RollSell(betterproto.Message):
    """
    The sender sells `roll_count` rolls. Roll price is defined in configuration
    """

    roll_count: int = betterproto.uint64_field(1)
    """Roll count"""


@dataclass(eq=False, repr=False)
class ExecuteSc(betterproto.Message):
    """Execute a smart contract"""

    data: bytes = betterproto.bytes_field(1)
    """Smart contract bytecode."""

    max_coins: int = betterproto.uint64_field(2)
    """The maximum of coins that could be spent by the operation sender"""

    max_gas: int = betterproto.uint64_field(3)
    """
    The maximum amount of gas that the execution of the contract is allowed to
    cost
    """

    datastore: List["BytesMapFieldEntry"] = betterproto.message_field(4)
    """A key-value store associating a hash to arbitrary bytes"""


@dataclass(eq=False, repr=False)
class CallSc(betterproto.Message):
    """Calls an exported function from a stored smart contract"""

    target_address: str = betterproto.string_field(1)
    """Target smart contract address"""

    target_function: str = betterproto.string_field(2)
    """Target function name. No function is called if empty"""

    parameter: bytes = betterproto.bytes_field(3)
    """Parameter to pass to the target function"""

    max_gas: int = betterproto.uint64_field(4)
    """
    The maximum amount of gas that the execution of the contract is allowed to
    cost
    """

    coins: "NativeAmount" = betterproto.message_field(5)
    """
    Extra coins that are spent from the caller's balance and transferred to the
    target
    """


@dataclass(eq=False, repr=False)
class SignedOperation(betterproto.Message):
    """Signed operation"""

    content: "Operation" = betterproto.message_field(1)
    """Operation"""

    signature: str = betterproto.string_field(2)
    """
    A cryptographically generated value using `serialized_data` and a public
    key.
    """

    content_creator_pub_key: str = betterproto.string_field(3)
    """The public-key component used in the generation of the signature"""

    content_creator_address: str = betterproto.string_field(4)
    """Derived from the same public key used to generate the signature"""

    secure_hash: str = betterproto.string_field(5)
    """
    A secure hash of the non-malleable contents of a deterministic binary
    representation of the block header
    """

    serialized_size: int = betterproto.uint64_field(6)
    """The size of the serialized operation in bytes"""


@dataclass(eq=False, repr=False)
class OperationWrapper(betterproto.Message):
    """A wrapper around an operation with its metadata"""

    block_ids: List[str] = betterproto.string_field(1)
    """The IDs of the blocks in which the operation appears"""

    thread: int = betterproto.uint32_field(2)
    """The thread in which the operation can be included"""

    operation: "SignedOperation" = betterproto.message_field(3)
    """The operation object itself"""


@dataclass(eq=False, repr=False)
class OperationInfo(betterproto.Message):
    """Information about an operation with its metadata"""

    id: str = betterproto.string_field(1)
    """The unique ID of the operation."""

    block_ids: List[str] = betterproto.string_field(2)
    """The IDs of the blocks in which the operation appears"""

    thread: int = betterproto.uint32_field(3)
    """The thread in which the operation can be included"""


@dataclass(eq=False, repr=False)
class OperationIds(betterproto.Message):
    """OperationIds"""

    operation_ids: List[str] = betterproto.string_field(1)
    """Operations ids"""


@dataclass(eq=False, repr=False)
class OpTypes(betterproto.Message):
    """OpTypes"""

    op_types: List["OpType"] = betterproto.enum_field(1)
    """Operations types"""


@dataclass(eq=False, repr=False)
class Block(betterproto.Message):
    """Block"""

    header: "SignedBlockHeader" = betterproto.message_field(1)
    """Signed header"""

    operations: List[str] = betterproto.string_field(2)
    """Operations ids"""


@dataclass(eq=False, repr=False)
class FilledBlock(betterproto.Message):
    """Filled block"""

    header: "SignedBlockHeader" = betterproto.message_field(1)
    """Signed header"""

    operations: List["FilledOperationEntry"] = betterproto.message_field(2)
    """Operations"""


@dataclass(eq=False, repr=False)
class BlockHeader(betterproto.Message):
    """Block header"""

    current_version: int = betterproto.uint32_field(1)
    """Current network version"""

    announced_version: Optional[int] = betterproto.message_field(
        2, wraps=betterproto.TYPE_UINT32
    )
    """Announced network version(Optional)"""

    slot: "Slot" = betterproto.message_field(3)
    """Slot"""

    parents: List[str] = betterproto.string_field(4)
    """parents"""

    operations_hash: str = betterproto.string_field(5)
    """All operations hash"""

    endorsements: List["SignedEndorsement"] = betterproto.message_field(6)
    """Signed endorsements"""

    denunciations: List["Denunciation"] = betterproto.message_field(7)
    """Denunciations"""


@dataclass(eq=False, repr=False)
class FilledOperationEntry(betterproto.Message):
    """Filled Operation Tuple"""

    operation_id: str = betterproto.string_field(1)
    """Operation id"""

    operation: "SignedOperation" = betterproto.message_field(2)
    """Signed operation"""


@dataclass(eq=False, repr=False)
class SignedBlock(betterproto.Message):
    """Signed block"""

    content: "Block" = betterproto.message_field(1)
    """Block"""

    signature: str = betterproto.string_field(2)
    """
    A cryptographically generated value using `serialized_data` and a public
    key.
    """

    content_creator_pub_key: str = betterproto.string_field(3)
    """The public-key component used in the generation of the signature"""

    content_creator_address: str = betterproto.string_field(4)
    """Derived from the same public key used to generate the signature"""

    secure_hash: str = betterproto.string_field(5)
    """
    A secure hash of the non-malleable contents of a deterministic binary
    representation of the block header
    """

    serialized_size: int = betterproto.uint64_field(6)
    """The size of the serialized block in bytes"""


@dataclass(eq=False, repr=False)
class SignedBlockHeader(betterproto.Message):
    """Signed block header"""

    content: "BlockHeader" = betterproto.message_field(1)
    """BlockHeader"""

    signature: str = betterproto.string_field(2)
    """
    A cryptographically generated value using `serialized_data` and a public
    key.
    """

    content_creator_pub_key: str = betterproto.string_field(3)
    """The public-key component used in the generation of the signature"""

    content_creator_address: str = betterproto.string_field(4)
    """Derived from the same public key used to generate the signature"""

    secure_hash: str = betterproto.string_field(5)
    """
    A secure hash of the non-malleable contents of a deterministic binary
    representation of the block header
    """

    serialized_size: int = betterproto.uint64_field(6)
    """The size of the serialized block header in bytes"""


@dataclass(eq=False, repr=False)
class BlockWrapper(betterproto.Message):
    """A wrapper around a block with its metadata"""

    status: "BlockStatus" = betterproto.enum_field(1)
    """The execution status of the block"""

    block: "Block" = betterproto.message_field(2)
    """The block object itself"""


@dataclass(eq=False, repr=False)
class BlockInfo(betterproto.Message):
    """Informations about a block with its metadata"""

    block_id: str = betterproto.string_field(1)
    """The unique ID of the block."""

    status: "BlockStatus" = betterproto.enum_field(2)
    """The execution status of the block"""


@dataclass(eq=False, repr=False)
class BlockIds(betterproto.Message):
    """BlockIds holds block ids"""

    block_ids: List[str] = betterproto.string_field(1)
    """Block ids"""


@dataclass(eq=False, repr=False)
class BlockParent(betterproto.Message):
    """Block parent tuple"""

    block_id: str = betterproto.string_field(1)
    """Block id"""

    period: int = betterproto.uint64_field(2)
    """Period"""


@dataclass(eq=False, repr=False)
class AddressKeysEntries(betterproto.Message):
    """AddressKeys holds a list of addresses - keys"""

    address_key_entries: List["AddressKeyEntry"] = betterproto.message_field(1)
    """List of address- key entries"""


@dataclass(eq=False, repr=False)
class AddressKeyEntry(betterproto.Message):
    """AddressKeyEntry"""

    address: str = betterproto.string_field(1)
    """Associated address of the entry"""

    key: bytes = betterproto.bytes_field(2)
    """Datastore key"""


@dataclass(eq=False, repr=False)
class DatastoreEntry(betterproto.Message):
    """DatastoreEntry"""

    final_value: bytes = betterproto.bytes_field(1)
    """final datastore entry value"""

    candidate_value: bytes = betterproto.bytes_field(2)
    """candidate_value datastore entry value"""


@dataclass(eq=False, repr=False)
class SlotDraw(betterproto.Message):
    """Slot draw"""

    slot: "Slot" = betterproto.message_field(1)
    """Slot"""

    block_producer: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """Block producer address (Optional)"""

    endorsement_draws: List["EndorsementDraw"] = betterproto.message_field(3)
    """Endorsement draws"""


@dataclass(eq=False, repr=False)
class EndorsementDraw(betterproto.Message):
    """Endorsement draw"""

    index: int = betterproto.uint64_field(1)
    """Endorsement index"""

    producer: str = betterproto.string_field(2)
    """Producer address"""


@dataclass(eq=False, repr=False)
class SlotExecutionOutput(betterproto.Message):
    """SlotExecutionOutput"""

    status: "ExecutionOutputStatus" = betterproto.enum_field(1)
    """Status"""

    execution_output: "ExecutionOutput" = betterproto.message_field(2)
    """Executed slot output"""


@dataclass(eq=False, repr=False)
class FinalizedExecutionOutput(betterproto.Message):
    """FinalizedExecutionOutput"""

    slot: "Slot" = betterproto.message_field(1)
    """Slot"""


@dataclass(eq=False, repr=False)
class ExecutionOutput(betterproto.Message):
    """ExecutionOutput"""

    slot: "Slot" = betterproto.message_field(1)
    """Slot"""

    block_id: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """Block id at that slot (Optional)"""

    events: List["ScExecutionEvent"] = betterproto.message_field(3)
    """Events emitted by the execution step"""

    state_changes: "StateChanges" = betterproto.message_field(4)
    """State changes caused by the execution step"""


@dataclass(eq=False, repr=False)
class ScExecutionEvent(betterproto.Message):
    """ScExecutionEvent"""

    context: "ScExecutionEventContext" = betterproto.message_field(1)
    """Sc execution context"""

    data: bytes = betterproto.bytes_field(2)
    """Generated data of the event"""


@dataclass(eq=False, repr=False)
class ScExecutionEventContext(betterproto.Message):
    """ScExecutionEvent context"""

    origin_slot: "Slot" = betterproto.message_field(1)
    """When was it generated"""

    block_id: Optional[str] = betterproto.message_field(
        2, wraps=betterproto.TYPE_STRING
    )
    """Block id if there was a block at that slot (Optional)"""

    index_in_slot: int = betterproto.uint64_field(3)
    """Index of the event in the slot"""

    call_stack: List[str] = betterproto.string_field(4)
    """Call stack addresses. most recent at the end"""

    origin_operation_id: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    """Origin operation id (Optional)"""

    is_failure: bool = betterproto.bool_field(6)
    """If a failure occurred"""

    status: "ScExecutionEventStatus" = betterproto.enum_field(7)
    """Status"""


@dataclass(eq=False, repr=False)
class ScExecutionEventsStatus(betterproto.Message):
    """ScExecutionEventsStatus"""

    status: List["ScExecutionEventStatus"] = betterproto.enum_field(1)
    """Status"""


@dataclass(eq=False, repr=False)
class StateChanges(betterproto.Message):
    """StateChanges"""

    ledger_changes: List["LedgerChangeEntry"] = betterproto.message_field(1)
    """Ledger changes"""

    async_pool_changes: List["AsyncPoolChangeEntry"] = betterproto.message_field(2)
    """Asynchronous pool changes"""

    executed_ops_changes: List["ExecutedOpsChangeEntry"] = betterproto.message_field(4)
    """Executed operations changes"""

    executed_denunciations_changes: List["DenunciationIndex"] = (
        betterproto.message_field(5)
    )
    """Executed denunciations changes"""

    execution_trail_hash_change: "SetOrKeepString" = betterproto.message_field(6)
    """Execution trail hash change"""


@dataclass(eq=False, repr=False)
class ExecutedOpsChangeEntry(betterproto.Message):
    """ExecutedOpsChangeEntry"""

    operation_id: str = betterproto.string_field(1)
    """string"""

    value: "ExecutedOpsChangeValue" = betterproto.message_field(2)
    """ExecutedOpsChangeValue"""


@dataclass(eq=False, repr=False)
class ExecutedOpsChangeValue(betterproto.Message):
    """ExecutedOpsChangeValue"""

    status: "OperationExecutionStatus" = betterproto.enum_field(1)
    """The status of the execution of the operation"""

    slot: "Slot" = betterproto.message_field(2)
    """Slot until which the operation remains valid (included)"""


@dataclass(eq=False, repr=False)
class AsyncPoolChangeEntry(betterproto.Message):
    """AsyncPoolChange Entry"""

    async_message_id: str = betterproto.string_field(1)
    """Async message id"""

    value: "AsyncPoolChangeValue" = betterproto.message_field(2)
    """AsyncPool message"""


@dataclass(eq=False, repr=False)
class AsyncPoolChangeValue(betterproto.Message):
    """AsyncPoolChangeValue"""

    type: "AsyncPoolChangeType" = betterproto.enum_field(1)
    """The type of the change"""

    created_message: "AsyncMessage" = betterproto.message_field(2, group="message")
    """Created ledger entry"""

    updated_message: "AsyncMessageUpdate" = betterproto.message_field(
        3, group="message"
    )
    """Update ledger entry"""


@dataclass(eq=False, repr=False)
class AsyncMessage(betterproto.Message):
    """Asynchronous smart contract message"""

    emission_slot: "Slot" = betterproto.message_field(1)
    """Slot at which the message was emitted"""

    emission_index: int = betterproto.uint64_field(2)
    """
    Index of the emitted message within the `emission_slot`. This is used for
    disambiguate the emission of multiple messages at the same slot.
    """

    sender: str = betterproto.string_field(3)
    """The address that sent the message"""

    destination: str = betterproto.string_field(4)
    """The address towards which the message is being sent"""

    handler: str = betterproto.string_field(5)
    """the handler function name within the destination address' bytecode"""

    max_gas: int = betterproto.uint64_field(6)
    """Maximum gas to use when processing the message"""

    fee: "NativeAmount" = betterproto.message_field(7)
    """Fee paid by the sender when the message is processed."""

    coins: "NativeAmount" = betterproto.message_field(8)
    """
    Coins sent from the sender to the target address of the message. Those
    coins are spent by the sender address when the message is sent, and
    credited to the destination address when receiving the message. In case of
    failure or discard, those coins are reimbursed to the sender.
    """

    validity_start: "Slot" = betterproto.message_field(9)
    """
    Slot at which the message starts being valid (bound included in the
    validity range)
    """

    validity_end: "Slot" = betterproto.message_field(10)
    """
    Slot at which the message stops being valid (bound not included in the
    validity range)
    """

    data: bytes = betterproto.bytes_field(11)
    """Raw payload data of the message"""

    trigger: "AsyncMessageTrigger" = betterproto.message_field(12)
    """Trigger that define whenever a message can be executed"""

    can_be_executed: bool = betterproto.bool_field(13)
    """
    Boolean that determine if the message can be executed. For messages without
    filter this boolean is always true. For messages with filter, this boolean
    is true if the filter has been matched between `validity_start` and current
    slot.
    """


@dataclass(eq=False, repr=False)
class AsyncMessageUpdate(betterproto.Message):
    """Asynchronous smart contract message"""

    emission_slot: "SetOrKeepSlot" = betterproto.message_field(1)
    """Change the slot at which the message was emitted"""

    emission_index: "SetOrKeepUint64" = betterproto.message_field(2)
    """
    Change the index of the emitted message within the `emission_slot`. This is
    used for disambiguate the emission of multiple messages at the same slot.
    """

    sender: "SetOrKeepString" = betterproto.message_field(3)
    """Change the address that sent the message"""

    destination: "SetOrKeepString" = betterproto.message_field(4)
    """Change the address towards which the message is being sent"""

    handler: "SetOrKeepString" = betterproto.message_field(5)
    """
    Change the handler function name within the destination address' bytecode
    """

    max_gas: "SetOrKeepUint64" = betterproto.message_field(6)
    """Change the maximum gas to use when processing the message"""

    fee: "SetOrKeepUint64" = betterproto.message_field(7)
    """Change the fee paid by the sender when the message is processed."""

    coins: "SetOrKeepUint64" = betterproto.message_field(8)
    """
    Change the coins sent from the sender to the target address of the message.
    Those coins are spent by the sender address when the message is sent, and
    credited to the destination address when receiving the message. In case of
    failure or discard, those coins are reimbursed to the sender.
    """

    validity_start: "SetOrKeepSlot" = betterproto.message_field(9)
    """
    Change the slot at which the message starts being valid (bound included in
    the validity range)
    """

    validity_end: "SetOrKeepSlot" = betterproto.message_field(10)
    """
    Change the slot at which the message stops being valid (bound not included
    in the validity range)
    """

    data: "SetOrKeepBytes" = betterproto.message_field(11)
    """Change the raw payload data of the message"""

    trigger: "SetOrKeepAsyncMessageTrigger" = betterproto.message_field(12)
    """Change the trigger that define whenever a message can be executed"""

    can_be_executed: "SetOrKeepBool" = betterproto.message_field(13)
    """
    Change the boolean that determine if the message can be executed. For
    messages without filter this boolean is always true. For messages with
    filter, this boolean is true if the filter has been matched between
    `validity_start` and current slot.
    """


@dataclass(eq=False, repr=False)
class SetOrKeepSlot(betterproto.Message):
    """Set or Keep Slot"""

    set: "Slot" = betterproto.message_field(1, group="change")
    """The value of that entry (Optional)"""

    keep: "Empty" = betterproto.message_field(2, group="change")
    """Keep the existing value"""


@dataclass(eq=False, repr=False)
class SetOrKeepUint64(betterproto.Message):
    """Set or Keep Uint64"""

    set: Optional[int] = betterproto.message_field(
        1, wraps=betterproto.TYPE_UINT64, group="change"
    )
    """The value of that entry (Optional)"""

    keep: "Empty" = betterproto.message_field(2, group="change")
    """Keep the existing value"""


@dataclass(eq=False, repr=False)
class SetOrKeepString(betterproto.Message):
    """Set or Keep String"""

    set: Optional[str] = betterproto.message_field(
        1, wraps=betterproto.TYPE_STRING, group="change"
    )
    """The value of that entry (Optional)"""

    keep: "Empty" = betterproto.message_field(2, group="change")
    """Keep the existing value"""


@dataclass(eq=False, repr=False)
class SetOrKeepBytes(betterproto.Message):
    """Set or Keep Bytes"""

    set: Optional[bytes] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BYTES, group="change"
    )
    """The value of that entry (Optional)"""

    keep: "Empty" = betterproto.message_field(2, group="change")
    """Keep the existing value"""


@dataclass(eq=False, repr=False)
class SetOrKeepBool(betterproto.Message):
    """Set or Keep Bool"""

    set: Optional[bool] = betterproto.message_field(
        1, wraps=betterproto.TYPE_BOOL, group="change"
    )
    """The value of that entry (Optional)"""

    keep: "Empty" = betterproto.message_field(2, group="change")
    """Keep the existing value"""


@dataclass(eq=False, repr=False)
class SetOrKeepAsyncMessageTrigger(betterproto.Message):
    """Set or Keep AsyncMessageTrigger"""

    set: "AsyncMessageTrigger" = betterproto.message_field(1, group="change")
    """The value of that entry (Optional)"""

    keep: "Empty" = betterproto.message_field(2, group="change")
    """Keep the existing value"""


@dataclass(eq=False, repr=False)
class AsyncMessageTrigger(betterproto.Message):
    """Structure defining a trigger for an asynchronous message"""

    address: str = betterproto.string_field(1)
    """Filter on the address"""

    datastore_key: Optional[bytes] = betterproto.message_field(
        2, wraps=betterproto.TYPE_BYTES
    )
    """Filter on the datastore key (Optional)"""


@dataclass(eq=False, repr=False)
class LedgerChangeEntry(betterproto.Message):
    """LedgerChangeEntry"""

    address: str = betterproto.string_field(1)
    """Address"""

    value: "LedgerChangeValue" = betterproto.message_field(2)
    """Ledger message"""


@dataclass(eq=False, repr=False)
class LedgerChangeValue(betterproto.Message):
    """LedgerChangeValue"""

    type: "LedgerChangeType" = betterproto.enum_field(1)
    """The type of the change"""

    created_entry: "LedgerEntry" = betterproto.message_field(2, group="entry")
    """Created ledger entry"""

    updated_entry: "LedgerEntryUpdate" = betterproto.message_field(3, group="entry")
    """Update ledger entry"""


@dataclass(eq=False, repr=False)
class LedgerEntry(betterproto.Message):
    """An entry associated to an address in the `FinalLedger`"""

    balance: "NativeAmount" = betterproto.message_field(1)
    """The balance of that entry"""

    bytecode: bytes = betterproto.bytes_field(2)
    """Executable bytecode"""

    datastore: List["BytesMapFieldEntry"] = betterproto.message_field(3)
    """A key-value store associating a hash to arbitrary bytes"""


@dataclass(eq=False, repr=False)
class LedgerEntryUpdate(betterproto.Message):
    """Represents an update to one or more fields of a `LedgerEntry`"""

    balance: "SetOrKeepBalance" = betterproto.message_field(1)
    """Change the balance"""

    bytecode: "SetOrKeepBytes" = betterproto.message_field(2)
    """Change the executable bytecode"""

    datastore: List["SetOrDeleteDatastoreEntry"] = betterproto.message_field(3)
    """Change datastore entries"""


@dataclass(eq=False, repr=False)
class SetOrKeepBalance(betterproto.Message):
    """Set or Keep Balance"""

    set: "NativeAmount" = betterproto.message_field(1, group="change")
    """The value of that entry (Optional)"""

    keep: "Empty" = betterproto.message_field(2, group="change")
    """Keep the existing value"""


@dataclass(eq=False, repr=False)
class SetOrDeleteDatastoreEntry(betterproto.Message):
    """Set or Delete DatastoreEntry"""

    set: "BytesMapFieldEntry" = betterproto.message_field(1, group="change")
    """Executable bytecode (Optional)"""

    delete: "Empty" = betterproto.message_field(2, group="change")
    """Delete the existing bytecode"""


@dataclass(eq=False, repr=False)
class ReadOnlyExecutionCall(betterproto.Message):
    """Read-only execution call"""

    max_gas: int = betterproto.uint64_field(1)
    """Maximum gas to spend in the execution."""

    call_stack: List["ExecutionStackElement"] = betterproto.message_field(2)
    """Call stack to simulate, older caller first"""

    bytecode_call: "BytecodeExecution" = betterproto.message_field(3, group="target")
    """Byte code"""

    function_call: "FunctionCall" = betterproto.message_field(4, group="target")
    """Function call"""

    caller_address: Optional[str] = betterproto.message_field(
        5, wraps=betterproto.TYPE_STRING
    )
    """
    Caller's address, (Optional) if not set, an auto-generated address will be
    used
    """

    fee: "NativeAmount" = betterproto.message_field(7)
    """fee paid by the caller when the call is processed (optional)"""


@dataclass(eq=False, repr=False)
class BytecodeExecution(betterproto.Message):
    """/ Execute a bytecode"""

    bytecode: bytes = betterproto.bytes_field(1)
    """Byte code"""

    operation_datastore: bytes = betterproto.bytes_field(2)
    """
    Serialized datastore (key value store)  for `ExecuteSC` Operation
    (Optional)
    """


@dataclass(eq=False, repr=False)
class FunctionCall(betterproto.Message):
    """Execute a function call"""

    target_address: str = betterproto.string_field(1)
    """Target address"""

    target_function: str = betterproto.string_field(2)
    """Target function"""

    parameter: bytes = betterproto.bytes_field(3)
    """Parameter to pass to the target function"""

    coins: "NativeAmount" = betterproto.message_field(4)
    """Coins transferred to the target address during the call"""


@dataclass(eq=False, repr=False)
class ReadOnlyExecutionOutput(betterproto.Message):
    """Structure describing the output of a read only execution"""

    out: "ExecutionOutput" = betterproto.message_field(1)
    """Output of a single execution"""

    used_gas: int = betterproto.uint64_field(2)
    """Gas cost for this execution"""

    call_result: bytes = betterproto.bytes_field(3)
    """Returned value from the module call"""


@dataclass(eq=False, repr=False)
class ExecutionStackElement(betterproto.Message):
    """
    Structure describing an element of the execution stack. Every time a
    function is called from bytecode, a new `ExecutionStackElement` is pushed
    at the top of the execution stack to represent the local execution context
    of the called function, instead of the caller's which should lie just below
    in the stack.
    """

    address: str = betterproto.string_field(1)
    """Called address"""

    coins: "NativeAmount" = betterproto.message_field(2)
    """Coins transferred to the target address during the call"""

    owned_addresses: List[str] = betterproto.string_field(3)
    """
    List of addresses owned by the current call, and on which the current call
    has write access. This list should contain `ExecutionStackElement::address`
    in the sense that an address should have write access to itself. This list
    should also contain all addresses created previously during the call to
    allow write access on newly created addresses in order to set them up, but
    only within the scope of the current stack element. That way, only the
    current scope and neither its caller not the functions it calls gain this
    write access, which is important for security. Note that we use a vector
    instead of a pre-hashed set to ensure order determinism, the performance
    hit of linear search remains minimal because `owned_addresses` will always
    contain very few elements.
    """

    operation_datastore: List["BytesMapFieldEntry"] = betterproto.message_field(4)
    """Datastore (key value store) for `ExecuteSC` Operation (Optional)"""


@dataclass(eq=False, repr=False)
class NativeTime(betterproto.Message):
    """NativeTime represents a native duration or unix timestamp"""

    milliseconds: int = betterproto.uint64_field(1)
    """Milliseconds"""


@dataclass(eq=False, repr=False)
class ConsensusStats(betterproto.Message):
    """Consensus statistics"""

    start_timespan: "NativeTime" = betterproto.message_field(1)
    """Start of the time span for stats"""

    end_timespan: "NativeTime" = betterproto.message_field(2)
    """End of the time span for stats"""

    final_block_count: int = betterproto.uint64_field(3)
    """Number of final blocks"""

    stale_block_count: int = betterproto.uint64_field(4)
    """Number of stale blocks in memory"""

    clique_count: int = betterproto.uint64_field(5)
    """Number of actives cliques"""


@dataclass(eq=False, repr=False)
class PoolStats(betterproto.Message):
    """Pool statistics"""

    endorsements_count: int = betterproto.uint64_field(1)
    """Endorsements"""

    operations_count: int = betterproto.uint64_field(2)
    """Operations"""


@dataclass(eq=False, repr=False)
class NetworkStats(betterproto.Message):
    """Network statistics"""

    in_connection_count: int = betterproto.uint64_field(1)
    """In connections count"""

    out_connection_count: int = betterproto.uint64_field(2)
    """Out connections count"""

    known_peer_count: int = betterproto.uint64_field(3)
    """Total known peers count"""

    banned_peer_count: int = betterproto.uint64_field(4)
    """Banned node count"""

    active_node_count: int = betterproto.uint64_field(5)
    """Active node count"""


@dataclass(eq=False, repr=False)
class ExecutionStats(betterproto.Message):
    """Execution statistics"""

    time_window_start: "NativeTime" = betterproto.message_field(1)
    """Time window start"""

    time_window_end: "NativeTime" = betterproto.message_field(2)
    """Time window end"""

    final_block_count: int = betterproto.uint64_field(3)
    """Number of final blocks in the time window"""

    final_executed_operations_count: int = betterproto.uint64_field(4)
    """Number of final executed operations in the time window"""


@dataclass(eq=False, repr=False)
class NodeStatus(betterproto.Message):
    """Node status"""

    node_id: str = betterproto.string_field(1)
    """Our node id"""

    node_ip: str = betterproto.string_field(2)
    """Optional node ip"""

    version: str = betterproto.string_field(3)
    """Node version"""

    current_time: "NativeTime" = betterproto.message_field(4)
    """Now"""

    current_cycle: int = betterproto.uint64_field(5)
    """Current cycle"""

    current_cycle_time: "NativeTime" = betterproto.message_field(6)
    """Current cycle starting timestamp"""

    next_cycle_time: "NativeTime" = betterproto.message_field(7)
    """Next cycle starting timestamp"""

    connected_nodes: List["ConnectedNode"] = betterproto.message_field(8)
    """Connected nodes"""

    last_executed_final_slot: "Slot" = betterproto.message_field(9)
    """Last executed final slot"""

    last_executed_speculative_slot: "Slot" = betterproto.message_field(10)
    """Last executed speculative slot"""

    final_state_fingerprint: str = betterproto.string_field(11)
    """The hash of the XOF final state hash"""

    consensus_stats: "ConsensusStats" = betterproto.message_field(12)
    """Consensus stats"""

    pool_stats: "PoolStats" = betterproto.message_field(13)
    """Pool stats (operation count and endorsement count)"""

    network_stats: "NetworkStats" = betterproto.message_field(14)
    """Network stats"""

    execution_stats: "ExecutionStats" = betterproto.message_field(15)
    """Execution stats"""

    config: "CompactConfig" = betterproto.message_field(16)
    """Compact configuration"""

    chain_id: int = betterproto.uint64_field(17)
    """Chain id"""

    current_mip_version: int = betterproto.uint32_field(18)
    """Current mip version"""


@dataclass(eq=False, repr=False)
class ConnectedNode(betterproto.Message):
    """Connected node"""

    node_id: str = betterproto.string_field(1)
    """Node id"""

    node_ip: str = betterproto.string_field(2)
    """Node ip"""

    connection_type: "ConnectionType" = betterproto.enum_field(3)
    """Connection type"""


@dataclass(eq=False, repr=False)
class CompactConfig(betterproto.Message):
    """Compact configuration"""

    genesis_timestamp: "NativeTime" = betterproto.message_field(1)
    """Time in milliseconds when the blockclique started."""

    end_timestamp: "NativeTime" = betterproto.message_field(2)
    """TESTNET: time when the blockclique is ended."""

    thread_count: int = betterproto.uint32_field(3)
    """Number of threads"""

    t0: "NativeTime" = betterproto.message_field(4)
    """Time between the periods in the same thread."""

    delta_f0: int = betterproto.uint64_field(5)
    """Threshold for fitness."""

    operation_validity_periods: int = betterproto.uint64_field(6)
    """Maximum operation validity period count"""

    periods_per_cycle: int = betterproto.uint64_field(7)
    """cycle duration in periods"""

    block_reward: "NativeAmount" = betterproto.message_field(8)
    """Reward amount for a block creation"""

    roll_price: "NativeAmount" = betterproto.message_field(9)
    """Price of a roll on the network"""

    max_block_size: int = betterproto.uint32_field(10)
    """Max total size of a block"""


@dataclass(eq=False, repr=False)
class PublicStatus(betterproto.Message):
    """Public status"""

    node_id: str = betterproto.string_field(1)
    """Our node id"""

    version: str = betterproto.string_field(3)
    """Node version"""

    current_time: "NativeTime" = betterproto.message_field(4)
    """Now"""

    current_cycle: int = betterproto.uint64_field(5)
    """Current cycle"""

    current_cycle_time: "NativeTime" = betterproto.message_field(6)
    """Current cycle starting timestamp"""

    next_cycle_time: "NativeTime" = betterproto.message_field(7)
    """Next cycle starting timestamp"""

    last_executed_final_slot: "Slot" = betterproto.message_field(8)
    """Last executed final slot"""

    last_executed_speculative_slot: "Slot" = betterproto.message_field(9)
    """Last executed speculative slot"""

    final_state_fingerprint: str = betterproto.string_field(10)
    """The hash of the XOF final state hash"""

    config: "CompactConfig" = betterproto.message_field(11)
    """Compact configuration"""

    chain_id: int = betterproto.uint64_field(12)
    """Chain id"""

    minimal_fees: "NativeAmount" = betterproto.message_field(13)
    """minimal fees"""

    current_mip_version: int = betterproto.uint32_field(14)
    """current mip version"""


@dataclass(eq=False, repr=False)
class StakerEntry(betterproto.Message):
    """StakerEntry"""

    address: str = betterproto.string_field(1)
    """Address"""

    rolls: int = betterproto.uint64_field(2)
    """Rolls"""


@dataclass(eq=False, repr=False)
class MipStatusEntry(betterproto.Message):
    """Entry for GetMipStatusResponse"""

    mip_info: "MipInfo" = betterproto.message_field(1)
    """Mip info"""

    state_id: "ComponentStateId" = betterproto.enum_field(2)
    """State id"""


@dataclass(eq=False, repr=False)
class MipInfo(betterproto.Message):
    """MIP info (name & versions & time range for a MIP)"""

    name: str = betterproto.string_field(1)
    """MIP name or descriptive name"""

    version: int = betterproto.uint32_field(2)
    """Network (or global) version (to be included in block header)"""

    start: "NativeTime" = betterproto.message_field(3)
    """
    A timestamp at which the version gains its meaning (e.g. announced in block
    header)
    """

    timeout: "NativeTime" = betterproto.message_field(4)
    """A timestamp at the which the deployment is considered failed"""

    activation_delay: "NativeTime" = betterproto.message_field(5)
    """
    Once deployment has been locked, wait for this duration before deployment
    is considered active
    """

    components: List["MipComponentEntry"] = betterproto.message_field(6)
    """
    Components concerned by this versioning (e.g. a new Block version), and the
    associated component_version
    """


@dataclass(eq=False, repr=False)
class MipComponentEntry(betterproto.Message):
    """MipComponentEntry"""

    kind: "MipComponent" = betterproto.enum_field(1)
    """Kind"""

    version: int = betterproto.uint32_field(2)
    """Version"""
